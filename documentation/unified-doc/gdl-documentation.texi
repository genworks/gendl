\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename gdl-documentation.info
@settitle 
@setchapternewpage odd
@c %**end of header

@ifnottex
@node Top
@top GDL Unified Documentation
@end ifnottex

@titlepage
@sp 10
@comment The title is printed in a large font.
@center @titlefont{GDL Unified Documentation}
@sp 1
@center version 1581 2011-09-26
@sp 2




@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2011 Genworks
@end titlepage

@iftex
@contents
@end iftex


@menu
* Introduction::
* Installation and Tips::
* Getting Started with Emacs::
* Getting Started with GDL Itself::
* Reference Documentation for GDL Objects, Operators, and Parameters::
* Other Documentation and Reference::
* Customer Support::
@end menu

@node Introduction
@chapter Introduction

The acronym GDL stands for General-Purpose Declarative Language.  By
General-Purpose it is meant that the language may be used to create a
wide spectrum of end results. It is a superior platform for creating
and deploying web-centric Knowledge-based Engineering and Business
applications. A particular strength of the platform is the high
efficiency in representing and evolving the definitions of complex
systems, including three-dimensional geometric models.

Existing and potential examples with geometry include automotive or
airplane wiring and hose systems, sheet metal surfaces, weld
optimization, baggage delivery carousels, fluid storage tanks and
boilers, airplane fuselages, wings, cabin configurations, other
components, a web-based e-learning application for model race cars,
``green'' cars, and bridge structures, with a 3D virtual world gaming
component --- plus many others. 

Examples without geometry include a Trucking company's national
delivery scheduling, a multi-national corporate Patent Tracking
system, an individual's computer Diary system.

@section What is GDL/GWL

GDL is a superset of ANSI Common Lisp (with case-sensitive ``modern
mode'' extensions), and consists mainly of automatic code-expanding
extensions to Common Lisp, implemented in the form of macros. When you
write, for example, 20 lines in GDL, you might be writing the
equivalent of 200 lines of Common Lisp. Of course, since GDL is a
superset of Common Lisp, you still have the full power of the CL
language at your fingertips whenever you are working in GDL.

Since GDL code expands into CL, everything you write in GDL will be
compiled ``down to the metal'' to machine code with all the
optimizations and safety that the tested-and-true CL compiler
provides. This is an important distinction when contrasted to some
other so-called KB or KBE systems on the market, which are really
nothing more than interpreted scripting languages which quickly meet
their limitations when pushed to compute something more demanding than
simple parameter-passing.

GDL is also a true declarative language. When you put together a GDL
application, you write and think mainly in terms of objects and their
properties, and how they depend on one another in a direct sense. You
do not have to track in your mind explicitly how one object or
property will “call” another object or property, in what order this
will happen, etc. Those details are taken care of for you
automatically by the language.  Because GDL is object-oriented, you
have all the features you would normally expect from an
object-oriented language, such as:

@sp 1
@itemize @bullet 
@item
Separation between the definition of an object and an instance of an object
@item
High levels of data abstraction
@item
The ability for one object to “inherit” from others
@item
The ability to “use” an object without concern for its “under-the-hood” implementation
@end itemize 

GDL supports the “message-passing” paradigm of object orientation,
with some extensions.  Since full-blown ANSI CLOS (Common Lisp Object
System) is always available as well, the Generic Function paradigm is
supported as well. Do not be concerned at this point if you are not
fully aware of the differences between these two
@uref{http://www.paulgraham.com/acl.html,, paradigms}.

GDL ships also with a standard web-development-component, the GWL
(Generative Web Language), which consists essentially of a set of
mixins and a few functions which provide a convenient mechanism to
present KB objects defined in GDL through a standard HTTP/HTML web
user interface.  GWL is designed to operate in conjunction with
@uref{http://opensource.franz.com,, AllegroServe} and a compatible
HTML generating facility such as cl-who or htmlgen. 


@section Packages and Licensing

Genworks offers GDL in a variety of packages, from Personal/Trial
Editions and Student Editions through to high-end Commercial packages.
The most popular packages are presented in the next sections.

@subsection Enterprise Edition Development Environment

The Enterprise Edition is for use in developing, building, and
deploying runtime applications in a networked corporate Enterprise
environment. It. includes:


@sp 1
@itemize @bullet 
@item @i{ All GDL/GWL Professional Edition components} 
@item @i{Ability to generate standalone runtime single-user and (web) server-based GDL/GWL applications, as well as shared-library (.DLL or .so) applications.}
@item @i{ Distributed GDL (dGDL), allowing child objects of GDL instance trees to exist on separate processes on local or remote server(s).}
@item  @i{Access to Relational Databases}
@item  @i{GDL integrated object-oriented relational database support, including table definition compiler and caching and dependency-tracking for database table and row objects}
@item  @i{GWL relational database user interface, providing default web-based access to insert, update, and delete database table rows}
@item  @i{Secure Socket Layer for building secure web server and client applications}
@item  @i{Enterprise customers are automatically licensed to generate and use Runtime Applications for noncommercial activities (e.g. deployment testing, demonstrations, etc.)}
@end itemize 


@subsection Professional Edition Development Environment


The Professional Edition is for use in the early phases of application
development. It does not include the capability to generate runtime
applications. It includes:

@sp 1
@itemize @bullet 
@item @i{GDL Compiler and Development Environment (integrated with CL/CLOS compiler)}
@item @i{Library of GDL Objects, Functions, and Macros}
@item @i{GWL Web Application Framework, integrated with a fully-featured web server}
@item @i{GWL-based GDL Object Tree Browser and Inspector}
@item @i{Fully cross-referenced web-based GDL/GWL reference documentation, tutorials, and a set of functioning sample applications} 
@item  @i{Base CL/CLOS compiler and development system with profiler and debugger}
@end itemize 

@subsection Evaluation and Student Edition Development Environment

The Evaluation and Student Editions are for evaluation or education
purposes. They do not include the capability to generate runtime
applications or direct support from Genworks @i{(the support is
provided via Genworks Google Group)}.

For additional Genworks products, pricing and support information
please visit the Web-site @uref{http://genworks.com}

@node Installation and tips
@chapter Installation and tips
@node Basic Installation
@section  Basic Installation

This section describes how to install GDL. To download the software
and retrieve a license key, follow the next steps:

@sp 1
@enumerate
@item
Visit the following URL: @uref{http://genworks.com/dl}

@item
Enter your email address. If you don't have an email address on file
with Genworks, send email to: @email{licensing@@genworks.com}.  Read
and accept the applicable license agreement and click the checkbox.

@item
Click the link to download the .zip or .exe install file, and start
the download to a known location on your computer.

@item
Click the "Retrieve License Key" link, to have your license key
file(s) emailed to you.

@end enumerate

GDL is currently distributed for all the platforms as a self-contained
"zip" file which does not require official administrator installation,
or an install executable ("exe") file. To install the downloaded
software, you can either:

@itemize @bullet 

@item

unzip the "zip" file to a known location or,

@item

(on Windows) run the installer executable (exe) file and follow the
prompts

@end itemize 

After the GDL application directory is in place (typically in
"c:/Program Files" on Windows, or "/usr/local/" on Linux), you have to
copy your license file in the GDL application directory. The license
file was obtained via email in a previous step, and should be named
either "devel.lic" for Enterprise or Student editions, or "gdl.lic"
for Professional/Trial versions. Now you can start the GDL development
environment by running the included "run-gdl.bat" startup script
(Windows) or "run-gdl" script (Linux/Mac).
 
@i{NOTE:} In current versions of GDL on Windows, the Start Menu item,
which gets installed by the Windows installation will invoke the
run-gdl.bat script which starts Emacs with GDL.  This method of
starting the GDL development environment can be used, so it is not
necessary to navigate to the GDL installation directory to run the
batch file on Windows, if the .exe installer has been used.



@node Becoming an effective GDL developer
@section Becoming an effective GDL developer

Becoming effective with GDL requires three (3) basic skills: 
@sp 1
@enumerate
@item
Editing text and managing files with Gnu Emacs (yes, other editors
will work, but Emacs provides special support and only Emacs is
supported by Genworks);
@item
Very basic Common Lisp programming;
@item
Writing Object Definitions in GDL itself, using the define-object
macro.
@end enumerate

Beyond this, if you want to create nice Web applications with GDL, it
helps to know something about HTML and server-based computing. But
these concepts can be picked up over time and are not necessary to get
started or to make simple applications or 3D geometric objects.

@node Getting Started with Emacs
@chapter Getting Started with Emacs
Assuming you followed the steps described in @ref{Basic Installation},
at this moment you now have Emacs running on your PC.  If not, start
Emacs with the GDL environment with the "run-gdl.bat" script (Windows)
or the "run-gdl" shell-script (Linux). Emacs should come up with
instructions for:

@enumerate
@item
How to use  Emacs 'basic tutorial'
@item
How to start the GDL process
@item
Instructions for using special keychord shortcuts in GDL
@end enumerate

@node How to use  Emacs 'basic tutorial'
@section How to use  Emacs 'basic tutorial'

GNU Emacs is an extensible, customizable text editor and more. At its
core is an interpreter for Emacs Lisp, a dialect of the Lisp
programming language with extensions to support text editing, for more
details see @uref{http://www.gnu.org/software/emacs/}. Note that Emacs
Lisp is a @i{different} Lisp process (memory space) and dialect from
the Common Lisp which hosts GDL. However the existence of Emacs Lisp
makes Emacs a very ``Lisp-aware'' environment.

The best way to become proficient in Emacs quickly is to invest
approximately 20-40 minutes and perform the built-in interactive
tutorial. This can be started (also in many languages alternative to
English) from the ``Help'' menu at the top of the Emacs screen.

To summarize the tutorial here: working in Emacs involves the use of a
CONTROL key (sometimes labeled CTRL or CTL) or the META key (sometimes
labeled EDIT or ALT). Rather than write that in full each time, in
Emacs the following abbreviations are used:

@sp 1
@itemize @bullet 
@item  @i{C-<chr>  means hold the CONTROL key while typing the character <chr>}

          For example; C-f would be: hold the CONTROL key and type f.

@item  @i{M-<chr>  means hold the META or EDIT or ALT key down while typing <chr>}

@end itemize 

Emacs is highly customizable and extensible, but it is not necessary
to master its full capabilities in order to become highly proficient
in GDL development. If you can commit the following commands to memory
in your first few days, it will greatly speed up your future
development:

@enumerate
@item
Viewing screen commands:

@itemize @bullet 
@item @i{C-g     Cancel any pending command -- very useful especially at the beginning, always remember to use this if you are unsure what is happening in Emacs}
@item  @i{C-v             Move forward one screenful}
@item  @i{M-v             Move backward one screenful}

@item  @i{C-x 2           Splits the screen into two windows}
@item  @i{M-x make-frame  Makes a new frame to appear on your screen}
@end itemize 

@item
Cursor-moving commands:

@itemize @bullet 
@item  @i{C-f   Move forward a character}
@item  @i{C-b   Move backward a character}

@item  @i{M-f   Move forward a word}
@item  @i{M-b   Move backward a word}

@item  @i{C-n   Move to next line}
@item  @i{C-p   Move to previous line}

@item  @i{C-a   Move to beginning of line}
@item  @i{C-e   Move to end of line}

@item  @i{M-a   Move back to beginning of sentence}
@item  @i{M-e   Move forward to end of sentence}
@end itemize

@item
Delete operation commands:

@itemize @bullet 
@item  @i{<Delback>    Delete the character just before the cursor}
@item  @i{C-d          Delete the next character after the cursor}

@item  @i{M-<Delback>  Kill the word immediately before the cursor}
@item  @i{M-d          Kill the next word after the cursor}

@item  @i{C-k          Kill from the cursor position to end of line}
@item  @i{M-k          Kill to the end of the current sentence}
@end itemize

@item
Other commands:

@itemize @bullet
@item  @i{C-x C-f       Find file}
@item  @i{C-x C-s       Save file}
@item  @i{C-x s         Save some buffers}
@item  @i{C-x C-b       List buffers}
@item  @i{C-x b         Switch buffer}
@item  @i{C-x C-c       Quit Emacs}
@item  @i{C-x 1         Delete all but one window}
@item  @i{C-x u         Undo}
@end itemize
@end enumerate

For more commands see the Emacs help menu or the GDL readme.txt which is automatically displayed at startup.

@node How to start and exit the GDL process
@section How to start and exit the GDL process

The GDL process starts automatically if the run-gdl batch file is
invoked as mentioned in @ref{Basic Installation}. Based on your
specific needs, the batch file can be edited as desired and for some
users, which are using Emacs as a daily text editor separate from GDL
work, the GDL startup process can be suppressed. For the previous
case, the GDL process can be started at any time from Emacs by typing:
@b{M-x gdl} (that's hold down the Meta or Alt key, and type x, then
type 'gdl' and press Enter). After starting GDL, it is recommended to
get the latest updates, extra modules, load the geometry kernel and
start the webserver. This can be accomplished by typing:

@sp 1
@smallexample

@b{(update-gdl)}



@end smallexample 
@sp 1

@i{Note: In Windows 7 is recommended to run GDL as administrator in order to performer an update-gdl call. This is required when new updates are available to be downloaded. If the updates are already downloaded the call can be performed by regular users.}  
   
Simply invoking the function @i{update-gdl} will update your GDL
platform to the latest stable patch level. It is also possible to
update your GDL platform to the latest build patch or to a specific
patch-level by invoking:

@sp 1
@smallexample
@b{(update-gdl :patch-level :nightly)}
or  (for example)
@b{(update-gdl :patch-level 010)}
@end smallexample
@sp 1
The function @i{update-gdl} is a complex function with many options,
so please see the @uref{http://localhost:9000/yadd,, yadd}
documentation on @i{update-gdl} or @i{gdl-updater} for a description
of all the options and what they do.

To end the GDL process and close Emacs it is recommended to follow the next two steps:
@sp 1 
@enumerate
@enumerate
@item
Type @b{:exit} at the command prompt in the *gdl toplevel* buffer and press the Enter or Return key;
this will kill the GDL process.
@item
Type C-x C-c (that's Ctrl-x, Ctrl-c) this will kill the Emacs process and exit the window.
@end enumerate
@end enumerate

@node Getting Started with GDL Itself
@chapter Getting Started with GDL Itself

The Genworks GDL language is a superset of ANSI Common Lisp (CL). If
you are new to the CL language, we recommend that you supplement this
chapter with other resources. Resources for Common Lisp abound in
bookstores and on the Web@footnote{http://www.cliki.net,
http://www.common-lisp.net}.  One example of a concise resource to get
started is Basic Lisp Techniques@footnote{http://www.genworks.com/downloads/blt-2011.pdf}, 
which also includes a small Genworks GDL example.


In the meantime, this chapter will provide a condensed overview of the
language. Please note, however, that this book is intended as a
summary, and will not delve into some of the more subtle and powerful
techniques possible with Common Lisp.

@node Overview of CL and its Syntax
@section Overview of CL and its Syntax

The first thing you should observe about GDL (and most languages in the Lisp family) is
that it uses a generalized @i{prefix} notation.

One of the most frequent actions in a CL program, or at the toplevel @i{read-eval-print} loop, 
is to call a @i{function}. This is most often done by writing an @i{expression} which names the 
function, followed by its arguments. Here is an example:

@sp 1
@code{@b{(+ 2 2)}}
@sp 1

This expression consists of the function named by the symbol @samp{+}, followed by the arguments
2 and another 2. As you may have guessed, when this expression is evaluated it will return
the value 4.

@i{Try it:} Try typing this expression at your command prompt, and see the return-value
being printed on the console.

@i{What is  actually happening here?} When CL is asked to @i{evaluate} an @i{expression} 
(as in the toplevel @i{read-eval-print} loop), it evaluates the expression according to the
following rules:

@enumerate
@item
If the expression is a number (i.e. looks like a number), it simply evaluates to itself (a
number):
@sp 1
@code{@b{gdl-user(1): 99}}

@code{@b{99}}
@sp 1

@item
If the expression looks like a @i{string} (i.e. is surrounded by double-quotes), it also simply
evaluates to itself:
@sp 1
@code{@b{gdl-user(2): "Our golden rule is simplicity"}}

@code{@b{"Our golden rule is simplicity"}}
@sp 1

@item
If the expression looks like a literal @i{symbol}, it will simply evaluate to that symbol
@sp 1
@code{@b{gdl-user(3): 'my-symbol}} 

@code{@b{my-symbol}}
@sp 1

@item
If the expression looks like a list (i.e. is surrounded by parentheses), CL assumes that
the @i{first} element in this list is a @i{symbol} which names a @i{function} or a @i{macro}, and
the @i{rest} of the elements in the list represent the @i{arguments} to the function or macro.
(We will discuss functions first, macros later). A function can take zero or more
arguments, and can return zero or more return-values. Often a function only returns
one return-value:

@code{@b{gdl-user(4): (expt 2 5)}} 

@code{@b{32}}
@sp 1
@end enumerate
@i{Try it:} Try typing the following functional expressions at your command prompt, and
convince yourself that the printed return-values make sense:

@cartouche
   
@sp 1
@code{@b{(+ 2 5)}} 
@sp 1
@code{@b{(+ 2)}} 
@sp 1
@code{@b{2}} 
@sp 1
@code{@b{(+ (+ 2 2) (+ 3 3 ))}}
@sp 1
@code{@b{(+ (+ 2 2))}} 
@sp 1
@code{@b{(sys:user-name)}}

@end cartouche
@node Fundamental CL Data Types
@section Fundamental CL Data Types

Common Lisp natively supports many data types common to other
languages, such as numbers, strings, and arrays. Native to CL is also
a set of types which you may not have come across in other languages,
such as lists, symbols, and hash tables. In this overview we will
focus on numbers, strings, symbols and lists.

Regarding data types, CL follows a paradigm called dynamic
typing. Basically this means that values have type, but variables do
not necessarily have type, and typically variables are not
``pre-declared'' to be of a particular type.

@subsection Numbers

Numbers in CL form a hierarchy of types, which includes Integers,
Ratios, Floating Point, and Complex numbers. For many purposes, you
only need to think of a value as a ``number'' without getting any more
specific than that. Most arithmetic operations, such as +, -, *, /,
etc, will automaticaly do any necessary type coercion on their
arguments and will return a number of the appropriate type.

CL supports a full range of floating-point decimal numbers, as well as
true Ratios, which means that 1/3 is a true one-third, not 0.333333333
rounded off at some arbitrary precision.

As we have seen, numbers in CL are a native data type which simply
evaluate to them- selves when entered at the toplevel or included in
an expression.

@subsection Strings

Strings are actually a specialized kind of array, namely a
one-dimensional array (vector) made up of characters. These characters
can be letters, numbers, or punctuation, and in some cases can include
characters from international character sets (e.g. Unicode) such as
Chinese Hanzi or Japanese Kanji. The string delimiter in CL is the
double-quote character.

As we have seen, strings in CL are a native data type which simply
evaluate to themselves when included in an expression.

@subsection Symbols

Symbols are such an important data structure in CL, that people
sometimes refer to CL as a ``Symbolic Computing Language.'' Symbols
are a type of CL object which provides your program with a built-in
mechanism to store and retrieve values and functions, as well as being
useful in their own right. A symbol is most often known by its name
(actually a string), but in fact there is much more to a symbol than
its name. In addition to the name, symbols also contain a @i{function}
slot, a @i{value} slot, and an open-ended @i{property-list} slot in
which you can store an arbitrary number of named properties.

For a named function such as @b{+} the function-slot of the symbol
@b{+} contains the actual function object. The value-slot of a symbol
can contain any value, allowing the symbol to act as a global
variable, or @i{parameter}. And the property-list, also known as the
@i{plist} slot, can contain an arbitrary amount of information.

This separation of the symbol data structure into function, value, and
plist slots is one obvious distinction between Common Lisp and most
other Lisp dialects. Most other dialects allow only one (1) ``thing''
to be stored in the symbol data structure, other than its name
(e.g. either a function or a value, but not both at the same
time). Because Common Lisp does not impose this restriction, it is not
necessary to contrive names, for example for your variables, to avoid
conflicting with existing ``reserved words'' in the system. For
example, @b{list} is the name of a built-in function in CL. But you
may freely use @b{list} as a variable name as well. There is no need to
contrive arbitrary abbreviations such as ``lst.''

How symbols are evaluated depends on where they occur in an
expression. As we have seen, if a symbol appears first in a list
expression, as with the @b{+} in @b{(+ 2 2)}, the symbol is evaluated
for its function slot. If the first element of an expression indeed
has a function in its function slot, then any subsequent symbol in the
expression is taken as a variable, and it is evaluated for its global
or local value, depending on its scope (more on variables and scope
later).

As noted in Section 3.1.3, if you want a literal symbol itself, one
way to achieve this is to ``quote'' the symbol name:

@smallexample
@b{'a}
@end smallexample

Another way is for the symbol to appear within a quoted list expression:

@smallexample
@b{'(a b c)}
@end smallexample 

@smallexample
@b{'(a (b c) d)}
@end smallexample 

Note that the quote (') applies across everything in the list
expression, including any sub- expressions.

@subsection Lists

Lisp takes its name from its strong support for the list data
structure. The list concept is important to CL for more than this
reason alone --- most notably, lists are important because @i{all CL
programs are themselves lists.}

Having the list as a native data structure, as well as the form of all
programs, means that it is straightforward for CL programs to compute
and generate other CL programs. Likewise, CL programs can read and
manipulate other CL programs in a natural manner. This cannot be said
of most other languages, and is one of the primary distinguishing
characteristics of Lisp as a language.

Textually, a list is defined as zero or more elements surrounded by
parentheses. The elements can be objects of any valid CL data types,
such as numbers, strings, symbols, lists, or other kinds of
objects. As we have seen, you must quote a literal list to evaluate it
or CL will assume you are calling a function.  Now look at the
following list:

@sp 1
@b{(defun hello () (write-string "Hello, World!"))}
@sp 1

This list also happens to be a valid CL program (function definition,
in this case). Don't worry about analyzing the function right now, but
do take a few moments to convince yourself that it meets the
requirements for a list. 

What are the types of the elements in this list?

In addition to using the quote (') to produce a literal list, another
way to produce a list is to call the function @b{list}. The function
@b{list} takes any number of arguments, and returns a list made up
from the result of evaluating each argument. As with all functions,
the arguments to the @b{list} function get evaluated, from left to
right, before being passed into the function. For example:

@sp 1
@b{(list ’a ’b (+ 2 2))}
@sp 1
will return the list 
@sp 1
@b{(a b 4)}
@sp 1
The two quoted symbols evaluate to symbols, and the function
call @b{(+ 2 2)} evaluates to the number 4.

@section Functions

Functions form the basic building blocks of CL. Here we will give a
brief overview on how to define a function; later we will go in more
detail on what a function actually is.

A common way to define named functions in CL is with the macro
@b{defun}, which stands for @i{DEFinition} of a @i{FUNction}. Defun
takes as arguments a symbol, an argument list, and a body:

@sp 1
@code{@b{gdl-user(5): (defun my-first-lisp-function () (list 'hello 'world))}}
@sp 1

Because defun is a macro, rather than a function, it does not
automatically evaluate all its arguments as expressions ---
specifically, the symbol which names the function does not have to be
quoted, nor does the argument list. These are taken as a literal
symbol and a literal list, respectively.

Once the function has been defined with defun, you can call it just as
you would call any other function, by wrapping it in parentheses
together with its arguments:

@cartouche
@code{@b{gdl-user(6): (my-first-lisp-function)}}
@sp 1
@code{@b{(hello world)}}
@sp 1
@code{@b{gdl-user(7): (defun square(x) (* x x)) }}
@sp 1
@code{@b{square}}
@sp 1
@code{@b{gdl-user(8): (square 4)}}
@sp 1
@code{@b{16}}
@sp 1
@end cartouche
@i{Note:} Declaring the types of the arguments to a function is not required.


FLAG -- Add sections on required, optional, and keyword arguments to
functions!!

@section Macros

Macros in CL provide a very powerful and flexible method of extending
CL syntax.  A CL macro is like a function that takes Lisp forms or
objects as input, and typically generates code to be then compiled and
executed. This happens before runtime, in a phase called
macroexpansion time. Macros can perform arbitrary computation during
expansion, using the full CL language.

One use of macros is transforming input representing arbitrary source
code into a version specified in terms of known definitions. In other
words, macros can add new syntax to the original language (this is
known as syntactic abstraction).

This enables easily embedding domain-specific languages, since
specialized syntax can be added before compile-time.

The chief benefit of macros is that they add power by letting the
programmer express intent clearly and with less code. Particularly,
one can add new features to the language that appear as if they were
built-in. In addition, when used to pre-emptively compute data or
initialize state, macros may aid in performance
optimisation. @uref{http://abhishek.geek.nz/docs/features-of-common-lisp/,,
@i{(source)}}.

Although we introduce macros to familiarize you with the concept, you
typically will have no need to author new macros when using GDL. In
fact, the GDL @i{kernel} (i.e. core software component) already
provides a general-purpose macro which covers the most typical
requirements for a generative application. This macro is called
@i{define-object}, introduced in the next section.

@section GDL Syntax

@subsection Define-Object

The @i{define-object} macro acts as the basic operator for defining
objects in GDL. An @i{object definition} acts a generic ``recipe'' or
``blueprint,'' from which specific @i{object instances} (also simply
called @i{objects}) may be generated.

The define-object macro takes three basic arguments:

@itemize @bullet
@item @i{a name}, which is a symbol;

@item @i{a mixin-list}, which is a list of symbols naming other objects from 
which the current object will @i{inherit} characteristics;

@item @i{a specification-plist}, which is spliced in (i.e. does not have its own 
surrounding parentheses) after the mixin-list, and describes the object model 
by specifying properties of the object (messages, contained objects, etc.) 
The specification-plist typically makes up the bulk of the object definition.
@end itemize 

Here are descriptions of the most common keywords which can be used in
the specification-plist:

@b{input-slots} specify information to be passed into the object
instance when it is created.

@b{computed-slots} specify ``formulas'' to compute a value on-demand.

@b{objects} specify the types and inputs for other objects which can
be instantiated on-demand and “contained” within this object.

@b{functions} specify (uncached) Lisp functions which take the current
object as the first argument and can also take additional arguments,
just like a normal CL function defined with @b{defun}.

@smallexample
@cartouche

(define-object hello ()

  :input-slots 
  (first-name last-name)

  :computed-slots
  ((greeting (format nil "Hello, ~a ~a!!"
                     (the first-name)
                     (the last-name)))))

@end cartouche
@end smallexample
@center Figure 1: Example of Simple Object Definition

Figure 2.1 shows a simple example, which contains two input-slots,
@b{first-name} and @b{last-name}, and a single computed-slot,
@b{greeting}. As you can see, a GDL Object is analogous in some ways
to a @b{defun}, where the input-slots are like arguments to the
function, and the computed-slots are like return values. But seen
another way, each computed-slot in a GDL object is like a function in
its own right.

The referencing macro @b{the} shadows CL’s @b{the} (which is a
seldom-used type declaration operator). @b{the} in GDL is used to
reference the value of other messages within the same object or within
contained objects. In the above example, we are using @b{the} to refer
to the values of the messages (input-slots) named @b{first-name} and
@b{last-name}.  Note that messages used with @b{the} are given as
symbols. These symbols are unaffected by the current Lisp
@b{*package*}, so they can be specified either as plain unquoted
symbols or as @i{keyword} symbols (i.e. symbols preceded by a colon),
and the @b{the} macro will process them identically.

In the previous example, the mixin-list is an empty list. As a
consequence, the object hello is a ``stand-alone'' object; it does not
inherit characteristics from any other definition within
GDL@footnote{Actually, this is a simplification. GDL contains a
built-in object definition called @b{vanilla-mixin}, which is
inherited automatically by all definitions created with
@b{define-object}.}.  Figure 2 shows an example containing the
definition of an object named my-circle-sample which inherit the
characteristics of the circle object defined in GDL.

@smallexample
@cartouche

(define-object my-circle-sample (circle)
  :computed-slots
  ((radius 10)))

@end cartouche
@end smallexample
@center Figure 2: Example of Simple Circle Object Definition

@subsection Making Instances and Sending Messages

Once we have defined an object such as the example above, we can use
the constructor function @b{make-object} in order to create an
@i{instance} of it. Below we create an instance of hello with
specified values for first-name and last-name (the required
input-slots), and assign this instance as the value of the symbol
my-instance:

@sp 1
@smallexample
gdl-user(9): (setq my-instance 
               (make-object 'hello 
                            :first-name "John"
                            :last-name "Doe"))

#<HELLO @ #x218f39c2>
@end smallexample
@sp 1

As you can see, @i{keyword} symbols are used to “tag” the input
values, and the return value is an instance of class hello (recall
that a keyword symbol is a symbol whose name is preceded by a colon
(``:'')). Now that we have an instance, we can use the macro
@b{the-object} to send messages to this instance:

@sp 1
@smallexample
gdl-user(9): (the-object my-instance greeting)

"Hello, John Doe!!"
@end smallexample
@sp 1

The-object is similar to the, but as its first argument it takes an
expression which evaluates to an object instance (typically, as in the
example above, this will just be a symbol which is acting as a
variable). @b{the}, by contrast, assumes that it is being used within
a particular object definition (i.e. within the code of a particular
@b{define-object}), and the message is assumed to be available in that
definition.

@smallexample
@cartouche

(define-object city ()
  :computed-slots
  ((total-water-usage (+ (the hotel water-usage)
                         (the bank water-usage))))
  :objects
  ((hotel :type 'hotel
          :size :large)
   (bank :type 'bank
         :size :medium)))

@end cartouche   
@end smallexample
@center Figure 3: Object Containing Child Objects

Similarly to @b{the}, @b{the-object} evaluates all (but the first) of
its arguments as package-immune symbols, so although keyword (preceded
by colon) symbols may be used, plain unquoted symbols will work just
as well.

For convenience, you can also set the special variable @b{self}
manually at the CL Command Prompt, and use @b{the} instead of
@b{the-object} for referencing:

@smallexample
gdl-user(10): (setq self
                (make-object 'hello :first-name "John"
                             :last-name "Doe"))

#<HELLO @ #x218f406a>
@end smallexample

@smallexample

gdl-user(11): (the greeting)

"Hello, John Doe!!"
@end smallexample

It may help to conceptualize that 

@smallexample
 (the ...) 
@end smallexample

is equivalent to

@smallexample
  (the-object self ...)
@end smallexample




@subsection Objects

The @b{:objects} keyword specifies a list of ``contained'' instances,
where each instance is considered to be a ``child'' object of the
current object. Each child object is of a specified type, which itself
must be defined with define-object before the child object can be
instantiated.  Input values to each instance are specified as a plist
of keywords and value expressions, spliced in (i.e. not inside their
own set of parentheses) after the object’s name and type
specification. These inputs must match the inputs protocol (i.e. the
@b{input-slots}) of the object being instantiated. 

Figure 2.2 shows an example of an object which contains some child
objects. In this example, @b{hotel} and @b{bank} are presumed to be
already (or soon to be) defined as objects themselves, which each
answer the @b{water-usage} message. The @i{reference chains:}

@smallexample
@sp 1
(the hotel water-usage)
@sp 1
@end smallexample
and 

@smallexample
@sp 1
(the bank water-usage)
@sp 1
@end smallexample

provide the mechanism to access messages within the child object instances.

These child objects become instantiated @i{on demand}, meaning that
the first time they or any of their messages are referenced, the
actual instance will be created and cached appropriately for future
reference.


@subsection Sequences of Objects and Input-slots with a Default Expression

@smallexample
@cartouche

(defparameter *presidents-data*
    '((:name
       "Carter"
       :term 1976)
      (:name "Reagan"
       :term 1980)
      (:name "Bush"   
       :term 1988)
      (:name "Clinton"
       :term 1992)))

(define-object presidents-container ()
  :input-slots
  ((data *presidents-data*))

  :objects
  ((presidents :type ’president
               :sequence (:size (length (the data)))
               :name (getf (nth (the-child index) (the data)) :name)
               :term (getf (nth (the-child index) (the data)) :term))))

@end cartouche 
@end smallexample
@center Figure 4: Sample Data and Object Definition to Contain U.S. Presidents



Objects may be @i{sequenced} , to specify, in effect, an array or list
of object instances. The most common type of sequence is called a
@i{standard} sequence. See Figure 4 for an example of an object
which contains a sequenced set of instances representing
U.S. presidents. Each member of the sequenced set is fed inputs from a
list of plists, which simulates a relational database table
(essentially a ``list of rows'').

Note the following from this example:

@itemize @bullet 
@item 
In order to sequence an object, the input keyword @b{:sequence} is added, with a list
consisting of the keyword @b{:size} followed by an expression which must evaluate to a
number.
@item 
In the input-slots, @b{data} is specified together with a default
expression. Used this way, input-slots function as a hybrid of
computed-slots and input-slots, allowing a @i{default expression} as
with computed-slots, but allowing a value to be passed in on
instantiation or from the parent, as with an input-slot which has no
default expression.  Note that a passed-in value will always override
the default expression.
@end itemize

This GDL syntax overview has been kept purposely brief, covering the
fundamentals of the language in a dense manner. On one hand, it is not
meant to be a comprehensive language reference; on the other hand, do
not be concerned if you are still unsure about some of the
terminology. The upcoming chapter will revisit and further expand many
of the topics covered here, and at some point a coherent picture
should begin to emerge.


@include development-of-projects.texi

@include tasty-interface.texi

@include drawing.texi


@node Custom User Interfaces in GDL
@chapter Custom User Interfaces in GDL

@include custom-user-interfaces.texi


@c @section Examples


@node Reference Documentation for GDL Objects; Operators; and Parameters
@chapter Reference Documentation for GDL Objects; Operators; and Parameters

@i{GDL contains auto-generated reference documentation for all its
built-in primitive objects and operators. This documentation can be
accessed from a live GDL session through the ``Documentation'' tab of
TaSty.}


@c @i{GDL contains auto-generated reference documentation for all its
@c built-in primitive objects, and operators. This documentation will be
@c compiled and included in this manual, but for now it can be accessed
@c from a live GDL session through the ``Documentation'' tab of TaSty.}

@c 
@c @i{The same documentation facility can also be used to document your own
@c application code; the procedure for doing this will also be included
@c as a section in this manual.}


@c This chapter describes the existing defined objects "classes" available in 
@c GDL. To be more consistent in this chapter we will addressee the predefined 
@c objects available in GDL as  primitive objects. The GDL Systems is an 
@c object-oriented programming language. It  make an important distinction 
@c between classes, which are generic descriptions of objects, and instances, 
@c which are specific objects. 

@c Instantiation is the process of creating a 
@c particular instance of a define-object. To create a particular instance of 
@c a define-object, you supply values for input-slots defined in the object 
@c definition. When the define-object is instantiated, a particular case of 
@c the generic define-object is created and this is the actual instance. 
@c However the instantiation of an object does not generate a geometric 
@c representation this is obtained by computing the define-object instance. 
@c In general terms as described in previous chapters the objects displayed 
@c in TaSty are computed instances of a define-object. 

@c Concluding this small introduction bellow each GDL primitive will be first 
@c generically described followed by an instance exemplification. The description 
@c is alphabetically ordered  for beginners it is recommended to follow the 
@c learning guide.    
@c

@c @section GDL Geometrical Primitives

@c The basic GDL primitives are grouped into the following packages: 

@c         - gdl

@c         - gwl
     
@c         - geom-base 

@c         - surf 

@include yadd/gdl.texi
@include yadd/gwl.texi
@include yadd/geom-base.texi
@include yadd/surf.texi

@c @node Other Documentation and Reference
@c @chapter Other Documentation and Reference

@c To Be Included here:

@c @itemize

@c @item Distributed GDL --- Connecting to child objects on a separate GDL process (on a local or remote host).

@c @item YADD --- Yet Another Definition Documenter (for generating your own reference docs for your applications).

@c @item Drawing --- more detail on the GDL drawing package and generating engineering drawings

@c @item Output  --- more detail on output-formats and lenses

@c @item Server Deployment --- deploying large-scale server-based runtime applications.

@c @end itemize


@node Customer Support
@chapter Customer Support

@b{Evaluation and Student Licensees} are not entitled to support
directly from Genworks. @i{Please register for the Genworks Google
Group then post your questions there.}

For @b{commercial licensees}, Genworks Customer support is
available. Support for all included components of GDL/GWL can be
provided by Genworks as your single point of contact. Our VAR
agreements with vendors such as Franz Inc. and SMS stipulate that
Genworks' customers contact only Genworks for support, and not
e.g. Franz Inc. or SMS directly. As necessary Genworks will follow up
with our vendors for second-level support on Allegro CL, SMLib, etc.

@b{@i{Genworks Technical Support can be reached at: @email{support@@genworks.com}.}}

@bye

