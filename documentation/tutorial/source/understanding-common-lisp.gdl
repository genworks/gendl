;;
;; Copyright 2002, 2009, 2012 Genworks International
;;
;; This source file is part of the General-purpose Declarative
;; Language project (GDL).
;;
;; This source file contains free software: you can redistribute it
;; and/or modify it under the terms of the GNU Affero General Public
;; License as published by the Free Software Foundation, either
;; version 3 of the License, or (at your option) any later version.
;; 
;; This source file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; Affero General Public License for more details.
;; 
;; You should have received a copy of the GNU Affero General Public
;; License along with this source file.  If not, see
;; <http://www.gnu.org/licenses/>.
;;

(in-package :gendl-doc)

(defparameter *understanding-common-lisp*
    `((:chapter :title "Understanding Common Lisp")
      (:p "Gendl is a superset of Common Lisp, and is embedded in Common
Lisp. This means that when working with Gendl, you have the full power
of CL available to you. The lowest-level expressions in a Gendl
definition are CL ``symbolic expressions,'' or ``s-expressions.''
This chapter will familiarize you with CL s-expressions.")
      ((:section :title "S-expression Fundamentals")
       (:p "S-expressions can be used in your definitions to establish
the value of a particular "
	   (:emph "slot")
	   " in an object, which will be computed on-demand. You can also
evaluate S-expressions at the toplevel "
	   (:texttt "gdl-user\\textgreater")
	   " prompt, and see the result immediately. In fact, this toplevel prompt is called a "
	   (:emph "read-eval-print")
	   " loop, because its purpose is to "
	   (:emph "read")
	   " each s-expression  entered, "
	   (:emph "evaluate")
	   " the expression to yield a result (or "
	   (:emph "return-value")
	   "), and finally to "
	   (:emph "print")
	   " that result.")

       (:p "CL s-expressions use a  "
	  (:emph "prefix")
	  " notation, which means that they consist of either an "
	  (:emph "atom")
	  " (e.g.  number, text string, symbol) or a list (one or more
	  items enclosed by parentheses, where the first item is
	  taken as a symbol which names an operator). Here is an example: "

	  (:verbatim "(+ 2 2)")

	  "This expression consists of the function named by the symbol "
	  (:texttt "+")
	  ", followed by the numeric arguments "
	  (:texttt "2") 
	  " and another "
	  (:texttt "2")
	  ". As you may have guessed, when this expression is evaluated it will return the value 4."
	  (:emph "Try it: ")
	  "try typing this expression at your command prompt, and see
the return-value being printed on the console. What is actually
happening here? When CL is asked to evaluate an expression, it
processes the expression according to the following rules:")
       (:p ((:list :style :itemize)
	    (:item "If the expression is an "
	      (:emph "atom")
	      " (e.g. a non-list datatype such as a number, text
string, or literal symbol), it simply evaluates to itself. Examples: "
	      ((:list :style :itemize 
		      (:item (:verbatim "gdl-user> 99
99"))
		      (:item (:verbatim "gdl-user> 99.9
99.9"))
		      (:item (:verbatim "gdl-user> 3/5
3/5"))
		      (:item (:verbatim "gdl-user> \"Bob\"
\"Bob\""))
		      (:item (:verbatim "gdl-user> \"Our golden rule is simplicity\"
\"Our golden rule is simplicity\""))
		      (:item (:verbatim "gdl-user> 'my-symbol
my-symbol"))))
	     "Note that numbers are represented directly (with decimal
points and slashes for fractions allowed), strings are surrounded by
double-quotes, and literal symbols are introduced with a preceding
single-quote. Symbols are allowed to have dashes (``-'') and most
other special characters. By convention, the dash is used as a word
separator in CL symbols.")

	    (:item "If the expression is a list (i.e. is surrounded by
parentheses), CL processes the "
	      (:emph "first")
	      " element in this list as an "
	      (:emph "operator name")
	      ", and the "
	      (:emph "rest")
	      " of the elements in the list represent the "
	      (:emph "arguments")
	      " to the operator. An operator can take zero or more
arguments, and can return zero or more return-values. Some operators
evaluate their arguments immediately and work directly on those
values (these are called "
	      (:emph "functions")
	      ". Other operators expand into other code. These are called "
	      (:emph "special operators")
	      " or "
	      (:emph "macros")
	      ". Macros are what give Lisp (and CL in particular) its
special power. Here are some examples of functional s-expressions: "
	      ((:list :style :itemize)
	       (:item (:verbatim "gdl-user> (expt 2 5)
32"))
	       (:item (:verbatim "gdl-user> (+ 2 5)
7"))
	       (:item (:verbatim "gdl-user> (+ 2)
2"))
	       (:item (:verbatim "gdl-user> (+ (+ 2 2) (+ 3 3 ))
10")))))))

      ((:section :title "Fundamental CL Data Types")
       
       (:p "As we have seen, Common Lisp natively supports
many data types common to other languages, such as numbers and text
strings. CL also contains several compound data types such as lists,
arrays, and hash tables. CL contains "
	   (:emph "symbols")
	   " as well, which typically are used as names for other data elements.")

       (:p "Regarding data types, CL follows a paradigm called dynamic
typing. Basically this means that values have type, but variables do
not necessarily have type, and typically variables are not
``pre-declared'' to be of a particular type.")

       ((:subsection :title "Numbers")
	(:p "As we have seen, numbers in CL are a native
data type which simply evaluate to themselves when entered at the
toplevel or included in an expression.")
	(:p "Numbers in CL form a hierarchy of types, which includes Integers,
Ratios, Floating Point, and Complex numbers. For many purposes, you
only need to think of a value as a ``number'' without getting any more
specific than that. Most arithmetic operations, such as "
	    (:texttt "+")
	    ", "
	    (:texttt "-")
	    ", "
	    (:texttt "*")
	    ", "
	    (:texttt "/")
	    " etc, will automaticaly do any necessary type coercion on their
arguments and will return a number of the appropriate type.

CL supports a full range of floating-point decimal numbers, as well as
true Ratios, which means that "
	    (:texttt "1/3")
	    " is a true one-third, not "
	    (:texttt "0.333333333")
	    " rounded off at some arbitrary precision."))
       ((:subsection :title "Strings")
	(:p "Strings are actually a specialized kind of
array, namely a one-dimensional array (vector) made up of text
characters. These characters can be letters, numbers, or punctuation,
and in some cases can include characters from international character
sets (e.g. Unicode or UTF-8) such as Chinese Hanzi or Japanese
Kanji. The string delimiter in CL is the double-quote character.")
	(:p "As we have seen, strings in CL are a native data type which simply
evaluate to themselves when included in an expression."))

       ((:subsection :title "Symbols")

	(:p "Symbols are such an important data structure in CL, that people
sometimes refer to CL as a ``Symbolic Computing Language.'' Symbols
are a type of CL object which provides your program with a built-in
mechanism to store and retrieve values and functions, as well as being
useful in their own right. A symbol is most often known by its name
 (actually a string), but in fact there is much more to a symbol than
its name. In addition to the name, symbols also contain a "
	    (:emph "function")
	    " slot, a "
	    (:emph "value")
	    " slot, and an open-ended "
	    (:emph "property-list")
	    " slot in which you can store an arbitrary number of named properties.")

	(:p "For a named function such as "
	    (:texttt "+")
	    " the function-slot contains the actual function
object for performing numeric addition. The value-slot of a symbol can
contain any value, allowing the symbol to act as a global variable, or "
	    (:emph "parameter")
	    ". And the property-list, also known as the "
	    (:emph "plist")
	    " slot, can contain an arbitrary amount of information.")
	(:p "This separation of the symbol data structure into function, value, and
plist slots is one obvious distinction between Common Lisp and most
other Lisp dialects. Most other dialects allow only one (1) ``thing''
to be stored in the symbol data structure, other than its name
 (e.g. either a function or a value, but not both at the same
time). Because Common Lisp does not impose this restriction, it is not
necessary to contrive names, for example for your variables, to avoid
conflicting with existing ``reserved words'' in the system. For
example, "
	    (:texttt "list")
	    " is the name of a built-in function in CL. But you
may freely use "
	    (:texttt "list")
	    " as a variable name as well. There is no need to
contrive arbitrary abbreviations such as "
	    (:texttt "lst")
	    ".")

	(:p "How symbols are evaluated depends on where they occur in an
expression. As we have seen, if a symbol appears first in a list
expression, as with the "
	    (:texttt "+")
	    " in "
	    (:texttt "(+ 2 2)")
	    ", the symbol is evaluated for its function slot. If the first 
element of an expression indeed has a function in its function slot, then any 
subsequent symbol in the expression is taken as a variable, and it is evaluated 
for its global or local value, depending on its scope (more on variables and 
scope later).")
	(:p "As noted in Section 3.1.3, if you want a literal symbol itself, one
way to achieve this is to ``quote'' the symbol name:"
	    (:verbatim "'a"))
	(:p "Another way is for the symbol to appear within a quoted list expression, for example:"
	    (:verbatim "'(a b c)")
	    " or "
	    (:verbatim "'(a (b c) d)"))
	(:p "Note that the quote ("
	    (:texttt "'")
	    ") applies across everything in the list expression, including any sub- expressions."))

       ((:subsection :title "Lists")
	(:p "Lisp takes its name from its strong support for the list data
structure. The list concept is important to CL for more than this
reason alone --- most notably, lists are important because "
	    (:emph "all CL programs are themselves lists."))
	(:p " Having the list as a native data structure, as well as the form of all
programs, means that it is straightforward for CL programs to compute
and generate other CL programs. Likewise, CL programs can read and
manipulate other CL programs in a natural manner. This cannot be said
of most other languages, and is one of the primary distinguishing
characteristics of Lisp as a language.")
	(:p "Textually, a list is defined as zero or more elements surrounded by
parentheses. The elements can be objects of any valid CL data types,
such as numbers, strings, symbols, lists, or other kinds of
objects. As we have seen, you must quote a literal list to evaluate it
or CL will assume you are calling a function. Now look at the
following list:"
	    (:verbatim "(defun hello () (write-string \"Hello, World!\"))")
	    "This list also happens to be a valid CL program (function definition,
in this case). Don't worry about analyzing the function definition
right now, but do take a few moments to convince yourself that it
meets the requirements for a list.")

	(:p "What are the types of the elements in this list?")

	(:p "In addition to using the quote (') to produce a literal list, another
way to produce a list is to call the function "
	    (:texttt "list")
	    ". The function "
	    (:texttt "list")
	    " takes any number of arguments, and returns a list made up
from the result of evaluating each argument. As with all functions,
the arguments to the "
	    (:texttt "list")
	    " function get evaluated, from left to right, before being
processed by the function. For example:"
	    (:verbatim "(list ’a ’b (+ 2 2))")
	    "will return the list"
	    (:verbatim "(a b 4)")
	    ". The two quoted symbols evaluate to symbols, and the function
call "
	    (:texttt "(+ 2 2)")
	    " evaluates to the number 4.")))))



#|

3.2 The List as a Data Structure

In this section we will present some of the fundamental native CL operators for manipulating

lists as data structures. These include operators for doing things such as:28 CHAPTER 3. THE CL LANGUAGE

1. ﬁnding the length of a list

2. accessing particular members of a list

3. appending multiple lists together to make a new list

4. extracting elements from a list to make a new list

3.2.1 Accessing the Elements of a List

Common Lisp deﬁnes the accessor functions first through tenth as a means of accessing

the ﬁrst ten elements in a list:

CL-USER(5): (first ’(a b c))

A

CL-USER(6): (second ’(a b c))

B

CL-USER(7): (third ’(a b c))

C

For accessing elements in an arbitrary position in the list, you can use the function nth,

which takes an integer and a list as its two arguments:

CL-USER(8): (nth 0 ’(a b c))

A

CL-USER(9): (nth 1 ’(a b c))

B

CL-USER(10): (nth 2 ’(a b c))

C

CL-USER(11): (nth 12 ’(a b c d e f g h i j k l m n o p))

M

Note that nth starts its indexing at zero (0), so (nth 0 ...) is equivalent to (first ...),

and (nth 1 ...) is equivalent to (second ...), etc.3.2. THE LIST AS A DATA STRUCTURE 29

3.2.2 The “Rest” of the Story

A very common operation in CL is to perform some operation on the first of a list, then

perform the same operation on each first of the rest of the list, repeating the procedure

until the end of the list, i.e. the Empty list, is reached. The function rest is very helpful

in such cases:

CL-USER(59): (rest ’(a b c))

(B C)

As you can see from this example, rest returns a list consisting of all but the first of its

argument.

3.2.3 The Empty List

The symbol NIL is deﬁned by Common Lisp to be equivalent to the Empty List, (). NIL

also has the interesting property that its value is itself, which means that it will always

evaluate to itself, whether or not it is quoted. So NIL, ’NIL, and () all evaluate to the

Empty List, whose default printed representation is NIL:

CL-USER(14): nil

NIL

CL-USER(15): ’nil

NIL

CL-USER(16): ()

NIL

The function null can be used to test whether or not something is the Empty List:

CL-USER(17): (null ’(a b c))

NIL

CL-USER(18): (null nil)

T

CL-USER(19): (null ())

T

As you may have deduced from the above examples, the symbol T is CL’s default representation for “true.” As with NIL, T evaluates to itself.

3.2.4 Are You a List?

To test whether or not a particular object is a list, CL provides the function listp. Like

many other functions which end with the letter “p,” this function takes a single argument

and checks whether it meets certain criteria (in this case, whether it qualiﬁes as a list).

These predicate functions ending in the letter “p” will always return either T or NIL:30 CHAPTER 3. THE CL LANGUAGE

CL-USER(20): (listp ’(pontiac cadillac chevrolet))

T

CL-USER(21): (listp 99)

NIL

CL-USER(22): (listp nil)

T

Note that (listp nil) returns T, since NIL is indeed a list (albeit the empty one).

3.2.5 The conditional If

Before continuing with a number of other basic list functions, we will cover the macro if,

which allows simple conditionals. If takes three arguments, a test-form, a then-form, and

an else-form. When an if form is evaluated, it ﬁrst evaluates its test-form. If the form

returns non-NIL, it will evaluate the then-form, else it will evaluate the else-form. The

nesting of multiple if expressions is possible, but not advised; later we will cover other

constructs which are more appropriate for such cases.

Here are some simple examples using the if operator:

CL-USER(2): (if (> 3 4)

"yes"

"no")

"no"

CL-USER(3): (if (listp ’("Chicago" "Detroit" "Toronto"))

"it is a list"

"it ain’t a list")

"it is a list"

CL-USER(4): (if (listp 99)

"it is a list"

"it ain’t a list")

"it ain’t a list"

3.2.6 Length of a List

Normally you can use the function length to get the number of elements in a list as an

integer:

CL-USER(5): (length ’(gm ford chrysler volkswagen))

43.2. THE LIST AS A DATA STRUCTURE 31

CL-USER(6): (length nil)

0

The length function, as with most of Common Lisp, can itself be implemented in CL. Here

is a simpliﬁed version of an our-length function which illustrates how length might be

implemented:

(defun our-length (list)

(if (null list)

0

(+ (our-length (rest list)) 1)))

Note that the function uses the symbol list to name its argument, which is perfectly valid

as we discussed in section 3.1.4.

In English, this function says basically: “If the list is empty, its length is zero. Otherwise

its length is one greater than the length of its rest.” As with many functions which operate

on lists, this recursive deﬁnition is a natural way to express the length operation.

3.2.7 Member of a List

The member function will help you to determine whether a particular item is an element of

a particular list. Like many similar functions, member uses eql to test for equality, which is

one of the most basic equality functions in CL (see Section 3.8.4 for a discussion of equality

in CL). Eql basically means the two objects must be the same symbol, integer, or actual

object (i.e. the same address in memory).

Member takes two arguments: an item and a list. If the item is not in the list, it returns

NIL. Otherwise, it returns the rest of the list, starting from the found element:

CL-USER(7): (member ’dallas ’(boston san-francisco portland))

NIL

CL-USER(8): (member ’san-francisco ’(boston san-francisco portland))

(SAN-FRANCISCO PORTLAND)

As with length, we could deﬁne member using a function deﬁnition which is very close to

the English description of what the function is supposed to do

3

:

(defun our-member (elem list)

(if (null list)

nil

(if (eql elem (first list))

list

(our-member elem (rest list)))))

3

The use of the “nested” if statement in this example, while functionally correc


In English, you might read this function to say “If the list is empty, return NIL. Otherwise,

if the desired item is the same as the first of the list, return the entire list. Otherwise, do

the same thing on the rest of the list.”

Note that, for the purposes of any kind of logical operators, returning any non-NIL value

is “as good as” returning T. So the possible return-values of the member function are as good

as returning T or NIL as far as any logical operators are concerned.

3.2.8 Getting Part of a List

Subseq is a common function to use for returning a portion of a list (or actually any type

of Sequence). Subseq takes at least two arguments, a list and an integer indicating the

position to start from. It also takes an optional third argument, an integer indicating the

position to stop. Note that the position indicated by this third argument is not included in

the returned sub-list:

CL-USER(9): (subseq ’(a b c d) 1 3)

(B C)

CL-USER(10): (subseq ’(a b c d) 1 2)

(B)

CL-USER(11): (subseq ’(a b c d) 1)

(B C D)

Note also that the optional third argument in eﬀect defaults to the length of the list.

3.2.9 Appending Lists

The function append takes any number of lists, and returns a new list which results from

appending them together. Like many CL functions, append does not side-eﬀect, that is, it

simply returns a new list as a return-value, but does not modify its arguments in any way:

CL-USER(6): (setq my-slides ’(introduction welcome lists functions))

(INTRODUCTION WELCOME LISTS FUNCTIONS)

CL-USER(7): (append my-slides ’(numbers))

(INTRODUCTION WELCOME LISTS FUNCTIONS NUMBERS)

CL-USER(8): my-slides

(INTRODUCTION WELCOME LISTS FUNCTIONS)

CL-USER(9): (setq my-slides (append my-slides ’(numbers)))

(INTRODUCTION WELCOME LISTS FUNCTIONS NUMBERS)

CL-USER(10): my-slides

(INTRODUCTION WELCOME LISTS FUNCTIONS NUMBERS)3.2. THE LIST AS A DATA STRUCTURE 33

Note that the simple call to append does not aﬀect the variable my-slides. If we wish

to modify the value of this variable, however, one way to do this is by using setq in

combination with the call to append. Note also the use of setq directly at the toplevel with

a new variable name. For testing and “hacking” at the command prompt, this is acceptable,

but in a ﬁnished program all such global variables should really be formally declared with

defparameter or defvar.

3.2.10 Adding Elements to a List

To add a single element to the front of a list, you can u


3.2.10 Adding Elements to a List

To add a single element to the front of a list, you can use the function cons:

CL-USER(13): (cons ’a ’(b c d))

(A B C D)

Cons is actually the low-level primitive function upon which many of the other list-constructing

functions are built. As you may have guessed, “cons” stands for “CONStruct,” as in “construct a list.” When you read or hear people talking about a CL program doing a lot of

“consing,” they are referring to the program’s behavior of building a lot of list structures,

many of which are transitory and will need to be “freed up” by the automatic memory

management subsystem, or “garbage collector.”

As with append, cons is non-destructive, meaning it does no side-eﬀecting (modiﬁcation)

to its arguments.

3.2.11 Removing Elements from a List

The function remove takes two arguments, any item and a list, and returns a new list with

all occurences of the item taken out of it:

CL-USER(15): (setq data ’(1 2 3 1000 4))

(1 2 3 1000 4)

CL-USER(16): (remove 1000 data)

(1 2 3 4)

CL-USER(17): data

(1 2 3 1000 4)

CL-USER(18): (setq data (remove 1000 data))

(1 2 3 4)

CL-USER(19): data

(1 2 3 4)

Like append and cons, remove is non-destructive and so does not modify its arguments. As

before, one way to achieve modiﬁcation with variables is to use setq.34 CHAPTER 3. THE CL LANGUAGE

3.2.12 Sorting Lists

The function sort will sort any sequence (including, of course, a list), based on comparing

the elements of the sequence using any applicable comparison function, or predicate function.

Because of eﬃciency reasons, the designers of CL made the decision to allow sort to modify

(“recycle” the memory in) its sequence argument — so you must always “catch” the result

of the sorting by doing something explicitly with the return-value:

CL-USER(20): (setq data ’(1 3 5 7 2 4 6))

(1 3 5 7 2 4 6)

CL-USER(21): (setq data (sort data #’<))

(1 2 3 4 5 6 7)

CL-USER(22): (setq data (sort data #’>))

(7 6 5 4 3 2 1)

Notice that the comparison function must be a function which can take two arguments —

any representative two elements in the given sequence — and compare them to give a T or

NIL result. The “#’” notation is a shorthand way of retrieving the actual function object

associated with a symbol or expression (in this case, the < or > symbol). We will cover more

on this in Section 3.4.

In the above examples, we simply reset the value of the variable data to the result of

the sort, which is a common thing to do. If one wanted to retain the original pre-sorted

sequence, a “safe” version of sort could be deﬁned as follows:

(defun safe-sort (list predicate)

(let ((new-list (copy-list list)))

(sort new-list predicate)))

3.2.13 Treating a List as a Set

The functions union, intersection, and set-difference take two lists and compute the

corresponding set operation. Because mathematical sets have no notion of ordering, the

order of the results returned by these functions is purely arbitrary, so you should never

depend on the results of these set operations being in any particular order:

CL-USER(23): (union ’(1 2 3) ’(2 3 4))

(1 2 3 4)

CL-USER(25): (intersection ’(1 2 3) ’(2 3 4))

(3 2)

CL-USER(26): (set-difference ’(1 2 3 4) ’(2 3))

(4 1)3.3. CONTROL OF EXECUTION 35

3.2.14 Mapping a Function to a List

If you have one list, and desire another list of the same length, there is a good chance that

you can use one of the mapping functions. Mapcar is the most common of such functions.

Mapcar takes a function and one or more lists, and maps the function across each element

of the list, producing a new resulting list. The term car comes from the original way in

Lisp of referring to the first of a list (“contents of address register”). Therefore mapcar

takes its function and applies it to the first of each successive rest of the list:

CL-USER(29): (defun twice (num)

(* num 2))

TWICE

CL-USER(30): (mapcar #’twice ’(1 2 3 4))

(2 4 6 8)

“Lambda” (unnamed) functions are used very frequently with mapcar and similar mapping

functions. More on this in Section 3.4.3.

3.2.15 Property Lists

Property lists (“plists”) provide a simple yet powerful way to handle keyword-value pairs.

A plist is simply a list, with an even number of elements, where each pair of elements

represents a named value. Here is an example of a plist:

(:michigan "Lansing" :illinois "Springfield"

:pennsylvania "Harrisburg")

In this plist, the keys are keyword symbols, and the values are strings. The keys in a plist

are very often keyword symbols. keyword symbols are symbols whose names are preceded by

a colon (:), and which are generally used just for matching the symbol itself (i.e. typically

they are not used for their symbol-value or symbol-function).

For accessing members of a plist, CL provides the function getf, which takes a plist

and a Key:

CL-USER(34): (getf ’(:michigan "Lansing"

:illinois "Springfield"

:pennsylvania "Harrisburg")

:illinois)

"Springfield"

3.3 Control of E


|#