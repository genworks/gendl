;;
;; Copyright 2002-2011 Genworks International 
;;
;; This source file is part of the General-purpose Declarative
;; Language project (GDL).
;;
;; This source file contains free software: you can redistribute it
;; and/or modify it under the terms of the GNU Affero General Public
;; License as published by the Free Software Foundation, either
;; version 3 of the License, or (at your option) any later version.
;; 
;; This source file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; Affero General Public License for more details.
;; 
;; You should have received a copy of the GNU Affero General Public
;; License along with this source file.  If not, see
;; <http://www.gnu.org/licenses/>.
;; 

(in-package :geysr)

(defparameter *trap-errors?* t)


(define-object tree (sheet-section)

  :documentation (:description "Implements an interactive graphical tree from a nested list using HTML list element and CSS.")
  
  :input-slots
  (("Function of one argument. This function takes a node in the tree as an argument, and should return
  a plist with keys :function and :arguments, which is a function in the bashee which will be called
  with the given arguments when the given node in the tree is clicked."
    onclick-function nil)

   (design-mode? nil)

   click-mode
   (respondent (the parent))
   (tree-dom-id (the dom-id))
   (target-object self)
   
   (display-controls-hash nil)
   
   (%tree-root% self)

   (expand-mode :remember :settable)
   
   (show-onmouseover-buttons? t)
   
   )

    
  :computed-slots 
  (
   ;;
   ;; This overrides the one from skeleton-ui-element because we don't want to filter
   ;; the root-object-object in the case of the tree. 
   ;;
   ;;(base64-encoded-root-path (base64-encode-safe (format nil "~s" (the root-path))))

   
   (tatu-color (or (when (getf (the local-display-controls) :color)
                     (string-append "#" (getf (the local-display-controls) :color)))
                   (multiple-value-bind (color error)
                       (with-error-handling () (the target-object color-hex))
                     (if (typep error 'error) (lookup-color :red :format :hex) color))))
                   
   
   
   (tatu-line-thickness (or (getf (the local-display-controls) :line-thickness)
                            (or (with-error-handling () (the target-object line-thickness)) 1)))

   
   #+nil
   (local-display-controls (gethash (the target-object) (the display-controls-hash)))

   (local-display-controls 
    (or (gethash (the target-object) (the display-controls-hash))
        (when (typep (the parent) 'tree) (the parent local-display-controls))))

   (kids-error (when (typep (the safe-children) 'error) (the safe-children)))
   
   (safe-children (append (if *trap-errors?* 
			      (the target-object safe-children)
			      (the target-object children))
                          (the target-object visible-children)))

   (safe-strings-for-display 
    (let ((string (multiple-value-bind (strings error)
                      (with-error-handling () (the target-object 
                                       strings-for-display))
                    (cond ((typep error 'error)
                           (format nil "! ~a ! from strings-for-display" error))
                          ((the color-error?)
                           (format nil "~a ! ~a ! from color-hex" strings 
                                   (the color-or-error)))
                          (t strings)))))
      (if (stringp string) string 
        (progn
          (warn "safe-strings-for-display returned non-string: ~s. 

Converting to a string to avoid error."
                string)
          (format nil "~s" string)))))

   (color-or-error (multiple-value-bind (color error)
                       (with-error-handling () (the target-object color-hex))
                     (if (typep error 'error) error color)))
   
   (color-error? (typep (the color-or-error) 'error))
   
   (color-hex (if (the color-error?) (lookup-color :red :format :hex) (the color-or-error)))
   
   (safe-child-first (length (the target-object safe-children)))
   
   (closed? (not (eql self (the %tree-root%))) :settable) 
   (open? (not (the closed?)))
   
   (child-nodes (list-elements (the nodes)))
   
   (inner-html
    (with-cl-who-string ()
      (if (the target-object)
	  (htm ((:ul :id "tree-root" :class "geysr-tree") 
		(str (the tree-node-view))))
	  (htm ((:span :class "geysr-tree")
		"No Object Instantiated")))))
   
   
   (tree-node-view
    (with-cl-who-string ()
  
      (:li
       (when (the child-nodes)
         (if (the closed?)
             (htm ((:span 
                    :class "directory far fa-plus-square" 
                    :title "Expand"
		    :style "cursor: default;"
                    :onclick (unless (the design-mode?) (the (gdl-ajax-call :function-key :toggle-state!))))))
             (htm ((:span 
                    :class "expanded far fa-minus-square"
		    :title "Collapse"
		    :style "cursor: default;"
                    :onclick (unless (the design-mode?)(the (gdl-ajax-call :function-key :toggle-state!))))))))

       (unless (the child-nodes)
         (htm ((:span :class "leaf fab fa-envira"))))

       ((:span :class "tree-node"
	       :title (glisp:replace-regexp (string-capitalize (the click-mode)) "-" " ")
	       :onclick (when (and (not (the design-mode?)) (the onclick-function))
                          (funcall  (the onclick-function) (the target-object))))
	(esc (the safe-strings-for-display)))

       
       ;; if there are siblings, make them here (inside the li)      
       (when (and (typep self 'tree) 
                  (the open?)
                  (the child-nodes))
         (htm
          (:ul
           (mapc #'(lambda (tree-node) 
                     (str (the-object tree-node tree-node-view)))
                 (the child-nodes)))))))))
 
  :functions
  ((toggle-state! ()
                  (the (set-slot! :closed? (not (the closed?))))
                  (the propogate-toggle!)
		  )
   
   (propogate-toggle! 
    ()
    (ecase (the expand-mode)

      (:auto-close (the %tree-root% (close-all! :except self))
         (the expand-parents!))
         
      
      (:children (mapc #'(lambda(node) (when (null (the-object node closed?))
                                         (the-object node (set-slot! :closed? t))))
                       (the child-nodes)))
      
      (:leaves (mapc #'(lambda(node) (the-object node open-all!)) 
                     (the child-nodes)))
      
      (:remember ;; do nothing
         ))
    
    )
   
   (open-all!
    ()
    (the (set-slot! :closed? nil))
    (mapc #'(lambda(node) (the-object node open-all!)) 
          (the child-nodes)))
   
   
   (close-all!
    (&key except)
    (unless (eql self except) (the (set-slot! :closed? t)))
    (mapc #'(lambda(node) (the-object node (close-all! :except except)))
          (the child-nodes)))
   
   (expand-parents!
    ()
    (when (and (the parent)
               (typep (the parent) 'tree))
      (the parent (set-slot! :closed? nil))
      (the parent expand-parents!)))
   
   (set-and-call-click-mode!
    (mode)
    (ecase mode
      (:inspect (the inspector (set-object! (the target-object))))
      (:add-leaves (the viewport (add-leaves! (the target-object))))
      (:highlight (if (the viewport (leaves-displayed? (the target-object)))
		      (the viewport (delete-leaves! (the target-object)))
		      (the viewport (add-leaves*! (the target-object))))))))

  
  :hidden-objects ((nodes :type 'tree
                          :sequence (:size (length (the safe-children)))
			  :remember-children? t
			  :pseudo-inputs (remember-children?) ;; FLAG -- need internal Gendl update to remove need for this. 
                          :pass-down (%tree-root% respondent onclick-function expand-mode display-controls-hash
                                                  show-onmouseover-buttons? click-mode)
                          :target-object (let ((node (nth (the-child index) (the safe-children))))
                                           (if (listp node)
                                               (make-object 'tasty-child-error
                                                            :error (getf node :error)
                                                            :object-key (getf node :object-key))
                                               node)))))

(define-object tasty-child-error ()
  :input-slots (error object-key)
  
  :computed-slots ((strings-for-display (format nil "~a threw error: ~a" (the object-key) (the error)))))
